
<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node {
  cursor: pointer;
}

.node circle {
  fill: #fff;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.node text {
  font: 16px sans-serif;
}

.link {
  fill: none;
  stroke: #ccc;
  stroke-width: 1.5px;
}

.selectedLink {
  fill: none;
  stroke: #222;
  stroke-width: 1.5px;
}

line {
    stroke: black;
    stroke-width: 1px;
}

</style>
<body>
<script src="/js/d3.v3.min.js"></script>
<script src="/js/sentencetree.js"></script>
<script src="/js/raphael-min.js"></script>
<script>

var margin = {top: 20, right: 120, bottom: 20, left: 120},
    width = 1260 - margin.right - margin.left,
    height = 1000 - margin.top - margin.bottom;
    
var i = 0,
    duration = 750,
    root;

var textSize = 16;

var sentenceTree = d3.layout.sentenceTree().size([height,
width]).textSize(textSize).textMargin(10);

var diagonal = d3.svg.diagonal().projection(function(d) { return [d.y, d.x]; });
var extendedDiagonal = d3.svg.diagonal().projection(function(d) { return [d.y, d.x]; });

var line;

var lineData = [];

function lineString()
{
  return "M"+lineData[0][0]+","+lineData[0][1]+"L"+lineData[1][0]+","+lineData[1][1];
}

var mouseIsDown=false;
function mousedown() {
  if (!mouseIsDown) {
    mouseIsDown=true;
    var m = d3.mouse(this);
    lineData[0] =  [m[0]-margin.left, m[1]-margin.top];
    lineData[1] =  [m[0]-margin.left, m[1]-margin.top];
    line = svg.append("line")
        .attr("x1", lineData[0][0])
        .attr("y1", lineData[0][1])
        .attr("x2", lineData[1][0])
        .attr("y2", lineData[1][1]);
  }
}

function mousemove() {
  if (mouseIsDown) {
    var m = d3.mouse(this);
    lineData[1] =  [m[0]-margin.left, m[1]-margin.top];
    line
        .attr("x2", lineData[1][0])
        .attr("y2", lineData[1][1]);
    pathSelection();
  }
}

function mouseup() {
  if (mouseIsDown)
  {
    var m = d3.mouse(this);
    var selectedSubTrees = pathSelection();
    cleanupPathSelection();
    var cutted = sentenceTree.cutEdgeMergeRear(selectedSubTrees);
    if (!cutted) {
      cutted = sentenceTree.cutEdgeMergeFront(selectedSubTrees);
      if (!cutted) {
        var ancestor = sentenceTree.mergeSelectedSubTrees(selectedSubTrees);
        if (ancestor)
          update(ancestor);
      } else 
        update(cutted);
    } else
      update(cutted);
  }
  mouseIsDown=false;
}

function cleanupPathSelection(){
  lineData[0] =  [0,0];
  lineData[1] =  [0,0];
  line
      .attr("x2", lineData[1][0])
      .attr("y2", lineData[1][1]);
  svg.select("line").remove();
  pathSelection();
}

function pathSelection(){
    var link = svg.selectAll("path.link");
    var selectedSubTrees=new Array();
    link[0].forEach(function(l){
      var intersects = Raphael.pathIntersection(l.attributes[1].value, lineString());
      if (intersects && intersects.length)
        selectedSubTrees.push(l.__data__.target);
    });
    link.filter(function(d,i){ 
      return (selectedSubTrees.indexOf(d.target)>=0);
      }).attr("style","stroke: #222");
    link.filter(function(d,i){ 
      return !(selectedSubTrees.indexOf(d.target)>=0);
      }).attr("style",null);
    return selectedSubTrees;
}

var svg = d3.select("body").append("svg")
    .attr("width", width + margin.right + margin.left)
    .attr("height", height + margin.top + margin.bottom)
      .style("-webkit-touch-callout","none")
      .style("-webkit-user-select","none")
      .style("-khtml-user-select","none")
      .style("-moz-user-select","none")
      .style("-ms-user-select","none")
      .style("user-select","none")

    .on("mousedown",mousedown)
    .on("mousemove",mousemove)
    .on("mouseup",mouseup)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

d3.json("/data/sentence.json", function(error, flare) {
  root = flare;
  root.x0 = height / 2;
  root.y0 = 0;
  sentenceTree.nodes(root);
  root.children.forEach(function(d){ d.collapse();});
  update(root);
});

d3.select(self.frameElement).style("height", "1000px");

function update(source) {

  // Compute the new tree layout.
  var nodes = sentenceTree.nodes(root).reverse(),
      links = sentenceTree.links(nodes);

  // Update the nodes…
  var node = svg.selectAll("g.node")
      .data(nodes, function(d) { return d.id || (d.id = ++i); });

  // Enter any new nodes at the parent's previous position.
  var nodeEnter = node.enter().append("g")
      .attr("class", "node")
      .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
      .style("-webkit-touch-callout","none")
      .style("-webkit-user-select","none")
      .style("-khtml-user-select","none")
      .style("-moz-user-select","none")
      .style("-ms-user-select","none")
      .style("user-select","none")

      .on("click", click);

  nodeEnter.append("circle")
       .style("-webkit-touch-callout","none")
      .style("-webkit-user-select","none")
      .style("-khtml-user-select","none")
      .style("-moz-user-select","none")
      .style("-ms-user-select","none")
      .style("user-select","none")
     .attr("r", 1e-5)
      .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

  nodeEnter.append("text")
      .attr("x", function(d) { return textSize; })
      .attr("dy", ".35em")
      .text(function(d) { return d.name; })
      .style("fill-opacity", 1e-5)
      .style("-webkit-touch-callout","none")
      .style("-webkit-user-select","none")
      .style("-khtml-user-select","none")
      .style("-moz-user-select","none")
      .style("-ms-user-select","none")
      .style("user-select","none")
      .attr("text-anchor", function(d) {
        return "start";
      });

  // Transition nodes to their new position.
  var nodeUpdate = node.transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

  nodeUpdate.select("circle")
      .attr("r", 6.5)
      .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

  nodeUpdate.select("text")
      .attr("x", function(d) { return textSize; })
      .attr("dy", ".35em")
      .text(function(d) { return d.name; })
      .style("fill-opacity", 1)
      .style("-webkit-touch-callout","none")
      .style("-webkit-user-select","none")
      .style("-khtml-user-select","none")
      .style("-moz-user-select","none")
      .style("-ms-user-select","none")
      .style("user-select","none")
      .attr("text-anchor", function(d) {
        return "start";
      });

  // Transition exiting nodes to the parent's new position.
  var nodeExit = node.exit().transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
      .remove();

  nodeExit.select("circle")
      .attr("r", 1e-5);

  nodeExit.select("text")
      .style("fill-opacity", 1e-5);

  // Update the links…
  var link = svg.selectAll("path.link")
      .data(links, function(d) { return d.target.id; });

  // Enter any new links at the parent's previous position.
  link.enter().insert("path", "g")
      .attr("class", "link")
      .style("-webkit-touch-callout","none")
      .style("-webkit-user-select","none")
      .style("-khtml-user-select","none")
      .style("-moz-user-select","none")
      .style("-ms-user-select","none")
      .style("user-select","none")

      .attr("d", function(d) {
        var o = {x: source.x0, y: source.y0};
        return diagonal({source: o, target: o});
      });

  // Transition links to their new position.
  link.transition()
      .duration(duration)
      .attr("d", diagonal);

  // Transition exiting nodes to the parent's new position.
  link.exit().transition()
      .duration(duration)
      .attr("d", function(d) {
        var o = {x: source.x, y: source.y};
        return diagonal({source: o, target: o});
      })
      .remove();

  // Stash the old positions for transition.
  nodes.forEach(function(d) {
    d.x0 = d.x;
    d.y0 = d.y;
  });
}

// Toggle children on click.
function click(d) {
  d.collapse();
  update(d);
}

</script>

